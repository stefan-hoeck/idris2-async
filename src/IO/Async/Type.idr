module IO.Async.Type

-- import Data.Nat
-- import IO.Async.Loop
-- import IO.Async.Internal.Ref
-- import Data.Linear.Deferred
-- import Data.Linear.Unique
-- import Syntax.T1
-- 
-- import public Control.Monad.MCancel
-- import public Data.Linear.ELift1
-- 
-- %default total
-- 
-- 
-- -- Cede control to the physical thread this fiber is running on
-- cedeFbr : EventLoop e -> FiberImpl e es a -> IO1 () -> IO1 ()
-- cedeFbr el fbr act = el.cede (Pkg fbr.env act)
-- 
-- 
-- 
-- parameters (limit   : Nat)
-- 
-- 
--   covering
--   spawnFib : EventLoop e -> FiberImpl e es a -> Async e es a -> IO1 ()
--   spawnFib el f act = el.spawn (Pkg f.env (run el act 0 limit f []))
-- 
--   run el act cm 0     fbr st t = cedeFbr el fbr (run el act cm limit fbr st) t
--   run el act 0  (S k) fbr st t =
--     case completedOnce1 fbr.cncl t of
--       False # t => runR el act 0 k fbr st t
--       True  # t => runC el act k fbr st t
--   run el act c  (S k) fbr st t = runR el act c k fbr st t
-- 
--   runC el act cc fbr st t =
--     case act of
--       UC f   => run el (f fbr.token 1) 1 cc fbr (Dec::st) t
--       Val x => case st of
--         Bnd f :: tl  => case f (Right x) of
--           UC g => run el (g fbr.token 1) 1 cc fbr (Dec::tl) t
--           a    => run el (pure ()) 1 cc fbr (hooks st) t
--         Inc :: tl    => run el (Val x) 1 cc fbr tl t
--         _           => run el (pure ()) 1 cc fbr (hooks st) t
--       Err x => case st of
--         Bnd f :: tl  => case f (Left x) of
--           UC g => run el (g fbr.token 1) 1 cc fbr (Dec::tl) t
--           a    => run el (pure ()) 1 cc fbr (hooks st) t
--         Inc :: tl    => run el (Err x) 1 cc fbr tl t
--         _           => run el (pure ()) 1 cc fbr (hooks st) t
--       _    => run el (pure ()) 1 cc fbr (hooks st) t
-- 
--   runR el act cm cc fbr st t =
--     case act of
--       Bind x f => case x of
--         Val x => run el (f x) cm cc fbr st t
--         Self  => run el (f fbr.token) cm cc fbr st t
--         _     => run el x cm cc fbr (Bnd (either Err f) :: st) t
-- 
--       Val x      => case st of
--         Bnd f  :: tl => run el (f $ Right x) cm        cc fbr tl t
--         Inc    :: tl => run el act   (S cm)    cc fbr tl t
--         Dec    :: tl => run el act   (pred cm) cc fbr tl t
--         -- ignore cancel hook because cancelation is currently not
--         -- observable.
--         Hook h :: tl => run el act   cm        cc fbr tl t
--         Abort  :: tl => finalize fbr Canceled t
--         []          => finalize fbr (Succeeded x) t
-- 
--       Err x      => case st of
--         Bnd f  :: tl => run el (f $ Left x) cm        cc fbr tl t
--         Inc    :: tl => run el act   (S cm)    cc fbr tl t
--         Dec    :: tl => run el act   (pred cm) cc fbr tl t
--         -- ignore cancel hook because cancelation is currently not
--         -- observable.
--         Hook h :: tl => run el act   cm        cc fbr tl t
--         Abort  :: tl => finalize fbr Canceled t
--         []          => finalize fbr (Error x) t
-- 
--       -- For certain fibers it is not necessary to actually spawn them
--       -- on the event loop, so we optimize those away.
--       Start x     => case x of
--         Asnc reg =>
--           let f2 # t := asynchronous reg t
--            in run el (pure f2) cm cc fbr st t
--         Cancel => run el (pure $ synchronous Canceled) cm cc fbr st t
--         Val v  => run el (pure $ synchronous (Succeeded v)) cm cc fbr st t
--         Err x  => run el (pure $ synchronous (Error x)) cm cc fbr st t
--         Self   => run el (pure $ synchronous (Succeeded fbr.token)) cm cc fbr st t
--         _ =>
--           let fbr2 # t := newFiber el t
--               _    # t := spawnFib el fbr2 x t
--            in run el (pure $ toFiber fbr2) cm cc fbr st t
-- 
--       Sync x      =>
--         let r # t := ioToF1 x t
--          in run el (terminal r) cm cc fbr st t
-- 
--       Attempt x => run el x cm cc fbr (Bnd Val :: st) t
-- 
--       Cancel      => 
--         let _ # t := putOnce1 fbr.cncl () t
--          in run el (pure ()) cm cc fbr st t
-- 
--       OnCncl x y  => run el x cm cc fbr (Hook y :: st) t
-- 
--       UC f        => run el (f fbr.token (S cm)) (S cm) cc fbr (Dec::st) t
-- 
--       Env         =>
--         let ev # t := read1 fbr.env t
--          in run el (pure ev) cm cc fbr st t
-- 
--       Cede        => cedeFbr el fbr (run el (pure ()) cm limit fbr st) t
-- 
--       Self        => run el (Val fbr.token) cm limit fbr st t
-- 
--       Asnc f =>
--         let o  # t := onceOf1 (Outcome es a) t
--             c1 # t := f (putOnce1 o . toOutcome) t
--             c2 # t := observeCancel o cm fbr t
--          in case peekOnce1 o t of
--               Nothing  # t =>
--                 let _ # t := observeOnce1 o (\out,t => case out of
--                                Succeeded r => let _ # t := c2 t in el.spawn (Pkg fbr.env $ run el (Val r) cm cc fbr st) t
--                                Error     x => let _ # t := c2 t in el.spawn (Pkg fbr.env $ run el (Err x) cm cc fbr st) t
--                                Canceled    => let _ # t := c1 t in el.spawn (Pkg fbr.env $ run el (pure ()) 1 cc fbr (hooks st)) t
--                              ) t
--                  in () # t
--               Just out # t => case out of
--                 Succeeded r => let _ # t := c2 t in run el (Val r) cm cc fbr st t
--                 Error     x => let _ # t := c2 t in run el (Err x) cm cc fbr st t
--                 Canceled    => let _ # t := c1 t in run el (pure ()) 1 cc fbr (hooks st) t
-- 
--       APoll tok k x => case tok == fbr.token && k == cm of
--         True  => run el x (pred cm) cc fbr (Inc :: st) t
--         False => run el x cm        cc fbr st t
-- 
--   export covering
--   runAsyncWith : EventLoop e -> Async e es a -> (Outcome es a -> IO ()) -> IO ()
--   runAsyncWith el act cb = runIO $ \t =>
--     let fbr # t := newFiber el t
--         _   # t := observeDeferredAs1 fbr.res fbr.token (\o => ioToF1 $ cb o) t
--      in spawnFib el fbr act t
--   
--   export covering %inline
--   runAsync : EventLoop e -> Async e es a -> IO ()
--   runAsync el as = runAsyncWith el as (\_ => pure ())
